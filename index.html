<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>曜弈棋 · 十米棋</title>
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 认证界面样式 */
        .auth-container {
            max-width: 90%;
            width: 320px;
            margin: 30px auto;
            padding: 25px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            text-align: center;
        }
        
        .auth-container h2 {
            color: #333;
            margin-bottom: 25px;
            font-size: 24px;
            font-weight: bold;
        }
        
        .auth-input {
            width: 100%;
            padding: 14px;
            margin: 12px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        .auth-button {
            width: 100%;
            padding: 14px;
            margin: 12px 0;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .auth-button:hover {
            background: linear-gradient(135deg, #45a049, #3d8b40);
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .auth-button:active {
            transform: translateY(0);
        }
        
        .auth-toggle {
            text-align: center;
            margin-top: 15px;
            cursor: pointer;
            color: #0066cc;
            font-size: 14px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .auth-toggle:hover {
            background-color: rgba(0, 102, 204, 0.05);
        }
        
        /* 游戏大厅样式 */
        .lobby-container {
            max-width: 90%;
            width: 320px;
            margin: 20px auto;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        
        .lobby-container h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 22px;
            font-weight: bold;
            text-align: center;
        }
        
        .lobby-container h3 {
            color: #666;
            margin: 15px 0 10px 0;
            font-size: 16px;
            font-weight: bold;
        }
        
        #currentUser {
            margin: 10px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
        }
        
        .player-list {
            margin: 15px 0;
        }
        
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #eee;
            border-radius: 8px;
            margin: 5px 0;
            background: #fafafa;
        }
        
        .player-item span {
            font-size: 14px;
            font-weight: 500;
        }
        
        .invite-button {
            padding: 8px 12px;
            background: linear-gradient(135deg, #0066cc, #0052a3);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .invite-button:hover {
            background: linear-gradient(135deg, #0052a3, #004080);
            transform: translateY(-1px);
        }
        
        .game-list {
            margin: 15px 0;
        }
        
        .game-item {
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 8px;
            margin: 10px 0;
            background: #fafafa;
        }
        
        .game-item div {
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .accept-button {
            padding: 8px 12px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 8px;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .accept-button:hover {
            background: linear-gradient(135deg, #45a049, #3d8b40);
        }
        
        .reject-button {
            padding: 8px 12px;
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .reject-button:hover {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
        }
        
        /* 游戏界面样式 */
        .game-info {
            display: flex;
            flex-direction: column;
            margin: 10px auto;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-width: 90%;
            width: 320px;
        }
        
        .game-info > div {
            margin: 5px 0;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
        }
        
        .logout-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        .logout-button:hover {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            transform: translateY(-1px);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }
        
        .controls button {
            padding: 10px 16px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .controls button:hover {
            background: linear-gradient(135deg, #45a049, #3d8b40);
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .controls button:active {
            transform: translateY(0);
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            min-height: 100vh;
            margin: 0;
        }
        
        h1 {
            color: #333;
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            margin-bottom: 15px;
            padding: 8px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        
        .status-item {
            font-size: 14px;
        }
        
        button {
            padding: 8px 16px;
            font-size: 14px;
        }
        
        #gameCanvas {
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            max-width: 100%;
            max-height: 80vh;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4488cc;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #3366aa;
        }
        
        button:active {
            background-color: #225599;
        }
        
        @media (max-width: 600px) {
            .status-bar {
                flex-direction: column;
                gap: 5px;
                align-items: center;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
                width: 100%;
            }
            
            button {
                width: 100%;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- 认证界面 -->
    <div id="authScreen" class="auth-container">
        <h2>登录/注册</h2>
        <input type="text" id="username" class="auth-input" placeholder="用户名">
        <input type="password" id="password" class="auth-input" placeholder="密码">
        <button id="loginBtn" class="auth-button">登录</button>
        <button id="registerBtn" class="auth-button">注册</button>
        <div class="auth-toggle" id="authToggle">切换到</div>
    </div>
    
    <!-- 游戏大厅 -->
    <div id="lobbyScreen" style="display: none;">
        <button id="logoutBtn" class="logout-button">退出登录</button>
        <div class="lobby-container">
            <h2>游戏大厅</h2>
            <div id="currentUser"></div>
            
            <h3>在线玩家</h3>
            <div id="playerList" class="player-list"></div>
            
            <h3>游戏邀请</h3>
            <div id="gameInvites" class="game-list"></div>
        </div>
    </div>
    
    <!-- 游戏界面 -->
    <div id="gameScreen" style="display: none;">
        <button id="exitGameBtn" class="logout-button">退出游戏</button>
        <h1>曜弈棋 · 十米棋</h1>
        
        <div class="game-info">
            <div>红方: <span id="redPlayer">-</span></div>
            <div>蓝方: <span id="bluePlayer">-</span></div>
            <div>状态: <span id="gameStatus">准备中</span></div>
        </div>
        
        <div class="status-bar">
            <div class="status-item">当前玩家: <span id="currentPlayer">红方</span></div>
            <div class="status-item">红方剩余: <span id="redCount">10</span></div>
            <div class="status-item">蓝方剩余: <span id="blueCount">10</span></div>
        </div>
        
        <canvas id="gameCanvas" width="385" height="385"></canvas>
        
        <div class="controls">
            <button id="surrenderBtn">投降</button>
            <button id="regretBtn">悔棋</button>
        </div>
    </div>
    
    <script>
        // Supabase配置
        const supabaseUrl = 'https://nxvcwyufmbpciccgjief.supabase.co';
        const supabaseKey = 'sb_publishable_AeEezx7Vi-S_eh7l4Vqh2w_dfhr-Ovh';
        
        // 使用不同的变量名避免冲突
        let sb;
        try {
            // 使用Supabase v2的正确初始化方法
            if (typeof supabase !== 'undefined' && supabase.createClient) {
                sb = supabase.createClient(supabaseUrl, supabaseKey);
                console.log('Supabase客户端初始化成功');
            } else {
                console.error('无法初始化Supabase客户端: supabase.createClient未找到');
                alert('无法连接到服务器，请稍后再试');
            }
        } catch (e) {
            console.error('初始化Supabase客户端时出错:', e);
            alert('无法连接到服务器，请稍后再试');
        }
        
        // 全局状态
        let currentUser = null;
        let currentGame = null;
        let realtimeChannel = null;
        
        // 游戏状态
        let boardState = {
            turn: 'red',
            red: {
                star: { x: 5, y: 10 },
                satellites: []
            },
            blue: {
                star: { x: 5, y: 0 },
                satellites: []
            },
            winner: null
        };
        
        // 游戏状态变量
        let selectedPiece = null; // 选中的棋子
        let lastClickTime = 0; // 双击检测
        let lastClickPos = { x: -1, y: -1 }; // 上次点击位置
        
        // 棋盘配置
        const GRID_SIZE = 11;
        const CELL_SIZE = 35; // 缩小单元格大小，适合手机屏幕
        const CANVAS_SIZE = GRID_SIZE * CELL_SIZE;
        
        // 初始化棋盘
        function initBoard() {
            // 重置游戏状态
            boardState = {
                turn: 'red',
                red: {
                    star: { x: 5, y: 10 },
                    satellites: []
                },
                blue: {
                    star: { x: 5, y: 0 },
                    satellites: []
                },
                winner: null
            };
            
            // 重置选中状态
            selectedPiece = null;
            
            // 初始化蓝方卫星（曜面）
            const blueSatellitePositions = [
                { x: 4, y: 0 }, { x: 6, y: 0 }, { x: 4, y: 1 }, { x: 6, y: 1 },
                { x: 5, y: 2 }, { x: 4, y: 3 }, { x: 6, y: 3 }, { x: 2, y: 4 }, { x: 8, y: 4 }
            ];
            blueSatellitePositions.forEach(pos => {
                boardState.blue.satellites.push({ pos, face: 'yao' });
            });
            
            // 初始化红方卫星（曜面）
            const redSatellitePositions = [
                { x: 4, y: 10 }, { x: 6, y: 10 }, { x: 4, y: 9 }, { x: 6, y: 9 },
                { x: 5, y: 8 }, { x: 4, y: 7 }, { x: 6, y: 7 }, { x: 2, y: 6 }, { x: 8, y: 6 }
            ];
            redSatellitePositions.forEach(pos => {
                boardState.red.satellites.push({ pos, face: 'yao' });
            });
            
            // 更新状态栏
            updateStatusBar();
            
            // 绘制棋盘
            drawBoard();
        }
        
        // 更新状态栏
        function updateStatusBar() {
            document.getElementById('currentPlayer').textContent = boardState.turn === 'red' ? '红方' : '蓝方';
            document.getElementById('redCount').textContent = 1 + boardState.red.satellites.length;
            document.getElementById('blueCount').textContent = 1 + boardState.blue.satellites.length;
        }
        
        // 绘制棋盘
        function drawBoard() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // 清空画布
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // 绘制网格
            drawGrid(ctx);
            
            // 绘制棋子
            drawPieces(ctx);
            
            // 绘制高亮
            if (selectedPiece) {
                drawHighlight(ctx, selectedPiece.pos);
            }
        }
        
        // 绘制网格
        function drawGrid(ctx) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            // 绘制垂直线
            for (let x = 0; x <= GRID_SIZE; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, CANVAS_SIZE);
                ctx.stroke();
            }
            
            // 绘制水平线
            for (let y = 0; y <= GRID_SIZE; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(CANVAS_SIZE, y * CELL_SIZE);
                ctx.stroke();
            }
        }
        
        // 绘制棋子
        function drawPieces(ctx) {
            // 绘制蓝方将星
            if (boardState.blue.star) {
                drawStar(ctx, boardState.blue.star, '#4488cc');
            }
            
            // 绘制红方将星
            if (boardState.red.star) {
                drawStar(ctx, boardState.red.star, '#c44');
            }
            
            // 绘制蓝方卫星
            boardState.blue.satellites.forEach(satellite => {
                drawSatellite(ctx, satellite.pos, '#4488cc', satellite.face);
            });
            
            // 绘制红方卫星
            boardState.red.satellites.forEach(satellite => {
                drawSatellite(ctx, satellite.pos, '#c44', satellite.face);
            });
        }
        
        // 绘制将星
        function drawStar(ctx, pos, color) {
            const centerX = (pos.x + 0.5) * CELL_SIZE;
            const centerY = (pos.y + 0.5) * CELL_SIZE;
            const radius = CELL_SIZE * 0.4;
            
            // 绘制外圈白环
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius + 3, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            
            // 绘制将星
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // 绘制卫星
        function drawSatellite(ctx, pos, color, face) {
            const centerX = (pos.x + 0.5) * CELL_SIZE;
            const centerY = (pos.y + 0.5) * CELL_SIZE;
            const radius = CELL_SIZE * 0.4;
            
            // 绘制卫星本体
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            
            // 绘制十字或米字
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            const lineLength = CELL_SIZE * 0.24;
            
            if (face === 'yao') {
                // 曜面：十字
                // 横线
                ctx.beginPath();
                ctx.moveTo(centerX - lineLength, centerY);
                ctx.lineTo(centerX + lineLength, centerY);
                ctx.stroke();
                
                // 竖线
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - lineLength);
                ctx.lineTo(centerX, centerY + lineLength);
                ctx.stroke();
            } else {
                // 弈面：米字
                // 横线
                ctx.beginPath();
                ctx.moveTo(centerX - lineLength, centerY);
                ctx.lineTo(centerX + lineLength, centerY);
                ctx.stroke();
                
                // 竖线
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - lineLength);
                ctx.lineTo(centerX, centerY + lineLength);
                ctx.stroke();
                
                // 左上-右下斜线
                ctx.beginPath();
                ctx.moveTo(centerX - lineLength, centerY - lineLength);
                ctx.lineTo(centerX + lineLength, centerY + lineLength);
                ctx.stroke();
                
                // 右上-左下斜线
                ctx.beginPath();
                ctx.moveTo(centerX + lineLength, centerY - lineLength);
                ctx.lineTo(centerX - lineLength, centerY + lineLength);
                ctx.stroke();
            }
        }
        
        // 绘制高亮
        function drawHighlight(ctx, pos) {
            const x = pos.x * CELL_SIZE;
            const y = pos.y * CELL_SIZE;
            
            ctx.fillStyle = 'rgba(68, 136, 204, 0.3)';
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
        }
        
        // 坐标转换：鼠标/触摸位置转棋盘坐标
        function getBoardPos(clientX, clientY) {
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = CANVAS_SIZE / rect.width;
            const scaleY = CANVAS_SIZE / rect.height;
            
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;
            
            const x = Math.floor(canvasX / CELL_SIZE);
            const y = Math.floor(canvasY / CELL_SIZE);
            
            // 边界检查
            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                return { x, y };
            }
            return null;
        }
        
        // 处理触摸事件
        function handleTouchStart(e) {
            e.preventDefault(); // 防止默认行为
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const pos = getBoardPos(touch.clientX, touch.clientY);
                if (pos) {
                    // 直接处理触摸位置，避免双击检测影响
                    handleSingleClick(pos);
                }
            }
        }
        
        // 处理Canvas点击事件
        function handleCanvasClick(e) {
            if (boardState.winner) return; // 游戏结束，不处理点击
            
            const pos = getBoardPos(e.clientX, e.clientY);
            if (!pos) return; // 点击在棋盘外
            
            const currentTime = Date.now();
            const timeDiff = currentTime - lastClickTime;
            
            // 双击检测
            if (timeDiff < 300 && lastClickPos.x === pos.x && lastClickPos.y === pos.y) {
                handleDoubleClick(pos);
                lastClickTime = 0;
                lastClickPos = { x: -1, y: -1 };
                return;
            }
            
            // 单击处理
            handleSingleClick(pos);
            
            // 更新点击状态
            lastClickTime = currentTime;
            lastClickPos = pos;
        }
        
        // 处理单击
        function handleSingleClick(pos) {
            console.log('处理单击，位置:', pos);
            // 检查是否点击了己方棋子
            const piece = getPieceAt(pos);
            
            // 确定当前玩家控制的颜色
            let currentPlayerColor = null;
            if (currentGame && currentUser) {
                if (currentGame.red_player_id === currentUser.id) {
                    currentPlayerColor = 'red';
                } else if (currentGame.blue_player_id === currentUser.id) {
                    currentPlayerColor = 'blue';
                }
            }
            
            // 检查是否是当前玩家的回合
            if (currentPlayerColor !== boardState.turn) {
                console.log('不是当前玩家的回合，无法移动棋子');
                return;
            }
            
            if (piece && piece.color === currentPlayerColor) {
                console.log('点击了己方棋子:', piece);
                if (piece.type === 'satellite') {
                    // 检查是否已经选中了将星，尝试换位
                    if (selectedPiece && selectedPiece.type === 'star' && selectedPiece.color === currentPlayerColor) {
                        console.log('尝试将星换位:', selectedPiece, '与', piece);
                        // 将星换位
                        if (isValidSwap(selectedPiece, piece)) {
                            console.log('将星换位有效，执行换位');
                            applySwap(selectedPiece, piece);
                            console.log('将星换位完成，切换回合');
                            switchTurn();
                            selectedPiece = null;
                            drawBoard();
                        }
                    } else {
                        // 检查是否点击了相同的卫星（翻面）
                        if (selectedPiece && selectedPiece.type === 'satellite' && 
                            selectedPiece.pos.x === pos.x && selectedPiece.pos.y === pos.y) {
                            console.log('点击了相同的卫星，尝试翻面');
                            // 卫星翻面
                            if (piece.side === 'red') {
                                if (piece.index !== undefined && piece.index < boardState.red.satellites.length) {
                                    boardState.red.satellites[piece.index].face = boardState.red.satellites[piece.index].face === 'yao' ? 'yi' : 'yao';
                                    console.log('红方卫星翻面完成');
                                }
                            } else if (piece.side === 'blue') {
                                if (piece.index !== undefined && piece.index < boardState.blue.satellites.length) {
                                    boardState.blue.satellites[piece.index].face = boardState.blue.satellites[piece.index].face === 'yao' ? 'yi' : 'yao';
                                    console.log('蓝方卫星翻面完成');
                                }
                            }
                            // 立即结束回合
                            console.log('卫星翻面完成，切换回合');
                            switchTurn();
                            selectedPiece = null;
                            drawBoard();
                        } else {
                            // 选中己方卫星
                            console.log('选中己方卫星:', piece);
                            selectedPiece = piece;
                            drawBoard();
                        }
                    }
                } else if (piece.type === 'star') {
                    // 选中己方将星
                    console.log('选中己方将星:', piece);
                    selectedPiece = piece;
                    drawBoard();
                }
            } else if (selectedPiece && selectedPiece.color === currentPlayerColor) {
                // 点击了其他位置，尝试移动
                console.log('尝试移动选中的棋子:', selectedPiece, '到位置:', pos);
                if (selectedPiece.type === 'satellite') {
                    // 检查是否为炮击
                    if (isValidCannon(selectedPiece, pos)) {
                        console.log('炮击有效，执行炮击');
                        applyCannon(selectedPiece, pos);
                        console.log('炮击完成，切换回合');
                        switchTurn();
                    } else if (isValidMove(selectedPiece, pos)) {
                        // 卫星移动
                        console.log('移动有效，执行移动');
                        applyMove(selectedPiece, pos);
                        console.log('移动完成，切换回合');
                        switchTurn();
                    } else {
                        console.log('移动无效');
                    }
                } else if (selectedPiece.type === 'star') {
                    // 将星操作
                    const targetPiece = getPieceAt(pos);
                    if (targetPiece && targetPiece.type === 'star' && targetPiece.color !== currentPlayerColor) {
                        // 将星对决
                        console.log('尝试将星对决:', selectedPiece, '与', targetPiece);
                        if (isValidDuel(selectedPiece, targetPiece)) {
                            console.log('将星对决有效，执行对决');
                            applyDuel(selectedPiece, targetPiece);
                        }
                    }
                }
                // 取消选中
                selectedPiece = null;
                drawBoard();
            }
        }
        
        // 处理双击（备用功能，主要用于手机端兼容性）
        function handleDoubleClick(pos) {
            const piece = getPieceAt(pos);
            if (piece && piece.color === boardState.turn) {
                if (piece.type === 'satellite') {
                    // 卫星翻面（备用方式）
                    if (piece.side === 'red') {
                        if (piece.index !== undefined && piece.index < boardState.red.satellites.length) {
                            boardState.red.satellites[piece.index].face = boardState.red.satellites[piece.index].face === 'yao' ? 'yi' : 'yao';
                        }
                    } else if (piece.side === 'blue') {
                        if (piece.index !== undefined && piece.index < boardState.blue.satellites.length) {
                            boardState.blue.satellites[piece.index].face = boardState.blue.satellites[piece.index].face === 'yao' ? 'yi' : 'yao';
                        }
                    }
                    // 立即结束回合
                    switchTurn();
                    drawBoard();
                }
            }
        }
        
        // 获取指定位置的棋子
        function getPieceAt(pos) {
            // 检查蓝方将星
            if (boardState.blue.star && boardState.blue.star.x === pos.x && boardState.blue.star.y === pos.y) {
                return { type: 'star', color: 'blue', pos: boardState.blue.star };
            }
            
            // 检查红方将星
            if (boardState.red.star && boardState.red.star.x === pos.x && boardState.red.star.y === pos.y) {
                return { type: 'star', color: 'red', pos: boardState.red.star };
            }
            
            // 检查蓝方卫星
            for (let i = 0; i < boardState.blue.satellites.length; i++) {
                const sat = boardState.blue.satellites[i];
                if (sat.pos.x === pos.x && sat.pos.y === pos.y) {
                    return { type: 'satellite', color: 'blue', pos: sat.pos, face: sat.face, index: i, side: 'blue' };
                }
            }
            
            // 检查红方卫星
            for (let i = 0; i < boardState.red.satellites.length; i++) {
                const sat = boardState.red.satellites[i];
                if (sat.pos.x === pos.x && sat.pos.y === pos.y) {
                    return { type: 'satellite', color: 'red', pos: sat.pos, face: sat.face, index: i, side: 'red' };
                }
            }
            
            return null;
        }
        
        // 初始化事件监听器
        function initEventListeners() {
            const canvas = document.getElementById('gameCanvas');
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            
            // 新开局按钮
            document.getElementById('newGameBtn').addEventListener('click', initBoard);
            
            // 投降按钮
            document.getElementById('surrenderBtn').addEventListener('click', function() {
                if (boardState.winner) return;
                boardState.winner = boardState.turn === 'red' ? 'blue' : 'red';
                alert(`${boardState.turn === 'red' ? '蓝方' : '红方'}胜利！`);
                drawBoard();
            });
        }
        
        // 检查路径是否无阻挡
        function isPathClear(start, end) {
            const dx = Math.abs(end.x - start.x);
            const dy = Math.abs(end.y - start.y);
            
            // 同一位置
            if (dx === 0 && dy === 0) return true;
            
            // 直线移动
            if (dx === 0 || dy === 0 || dx === dy) {
                const stepX = (end.x - start.x) / Math.max(dx, dy);
                const stepY = (end.y - start.y) / Math.max(dx, dy);
                
                let x = start.x + stepX;
                let y = start.y + stepY;
                
                while (x !== end.x || y !== end.y) {
                    if (getPieceAt({ x: Math.round(x), y: Math.round(y) })) {
                        return false;
                    }
                    x += stepX;
                    y += stepY;
                }
                return true;
            }
            
            return false;
        }
        
        // 检查炮击路径是否无阻挡（排除炮架）
        function isCannonPathClear(start, end) {
            const dx = Math.abs(end.x - start.x);
            const dy = Math.abs(end.y - start.y);
            
            // 同一位置
            if (dx === 0 && dy === 0) return true;
            
            // 直线移动
            if (dx === 0 || dy === 0 || dx === dy) {
                const stepX = (end.x - start.x) / Math.max(dx, dy);
                const stepY = (end.y - start.y) / Math.max(dx, dy);
                
                let x = start.x + stepX;
                let y = start.y + stepY;
                
                while (x !== end.x || y !== end.y) {
                    const pos = { x: Math.round(x), y: Math.round(y) };
                    if (getPieceAt(pos)) {
                        return false;
                    }
                    x += stepX;
                    y += stepY;
                }
                return true;
            }
            
            return false;
        }
        
        // 检查卫星是否为护卫
        function isGuard(satellite) {
            const star = boardState[satellite.color].star;
            if (!star) return false;
            
            const dx = Math.abs(satellite.pos.x - star.x);
            const dy = Math.abs(satellite.pos.y - star.y);
            
            return dx <= 1 && dy <= 1;
        }
        
        // 检查是否可以攻击护卫
        function canAttackGuard(attacker, defender) {
            return attacker.face !== defender.face;
        }
        
        // 验证卫星移动合法性
        function isValidMove(satellite, target) {
            // 检查目标位置是否有己方棋子
            const targetPiece = getPieceAt(target);
            if (targetPiece && targetPiece.color === satellite.color) {
                return false;
            }
            
            // 检查移动方向是否符合当前面
            const dx = Math.abs(target.x - satellite.pos.x);
            const dy = Math.abs(target.y - satellite.pos.y);
            
            // 检查移动距离（只能移动一格）
            if (satellite.face === 'yao') {
                // 曜面：只能横竖移动，且只能移动一格
                if (dx !== 0 && dy !== 0) {
                    return false;
                }
                if (dx > 1 || dy > 1) {
                    return false;
                }
            } else {
                // 弈面：只能斜线移动，且只能移动一格
                if (dx !== dy) {
                    return false;
                }
                if (dx > 1 || dy > 1) {
                    return false;
                }
            }
            
            // 检查路径是否无阻挡
            if (!isPathClear(satellite.pos, target)) {
                return false;
            }
            
            // 检查是否攻击护卫
            if (targetPiece && targetPiece.type === 'satellite' && isGuard(targetPiece)) {
                if (!canAttackGuard(satellite, targetPiece)) {
                    return false;
                }
            }
            
            return true;
        }
        
        // 验证将星换位合法性
        function isValidSwap(star, satellite) {
            // 检查卫星是否为己方
            if (satellite.color !== star.color) {
                return false;
            }
            
            // 检查卫星是否在将星九宫格内
            const dx = Math.abs(satellite.pos.x - star.pos.x);
            const dy = Math.abs(satellite.pos.y - star.pos.y);
            
            return dx <= 1 && dy <= 1;
        }
        
        // 验证将星对决合法性
        function isValidDuel(sourceStar, targetStar) {
            // 检查是否为敌方将星
            if (sourceStar.color === targetStar.color) {
                return false;
            }
            
            // 检查是否同线
            const dx = Math.abs(targetStar.pos.x - sourceStar.pos.x);
            const dy = Math.abs(targetStar.pos.y - sourceStar.pos.y);
            
            if (dx !== 0 && dy !== 0 && dx !== dy) {
                return false;
            }
            
            // 检查路径是否无阻挡
            return isPathClear(sourceStar.pos, targetStar.pos);
        }
        
        // 验证炮击合法性（象棋炮规则：需要中间有一个棋子作为炮架）
        function isValidCannon(source, target) {
            // 检查目标是否为敌方棋子
            const targetPiece = getPieceAt(target);
            if (!targetPiece || targetPiece.color === source.color) {
                return false;
            }
            
            // 检查是否攻击护卫
            if (targetPiece.type === 'satellite') {
                if (isGuard(targetPiece)) {
                    if (!canAttackGuard(source, targetPiece)) {
                        return false;
                    }
                }
            }
            
            // 检查是否有相邻同面卫星
            const adjacentSats = getAdjacentSameFaceSatellites(source);
            if (adjacentSats.length === 0) {
                return false;
            }
            
            // 检查是否共线
            const dx = Math.abs(target.x - source.pos.x);
            const dy = Math.abs(target.y - source.pos.y);
            
            if (source.face === 'yao') {
                // 曜面炮：只能打横竖方向
                if (dx !== 0 && dy !== 0) {
                    return false;
                }
            } else {
                // 弈面炮：只能打斜线方向
                if (dx !== dy) {
                    return false;
                }
            }
            
            // 检查是否背向相邻卫星方向（后方的棋子飞去对面）
            let validDirection = false;
            for (const adjacentSat of adjacentSats) {
                // 计算相邻卫星与目标的方向关系
                const adjDx = source.pos.x - adjacentSat.pos.x;
                const adjDy = source.pos.y - adjacentSat.pos.y;
                const targetDx = target.x - source.pos.x;
                const targetDy = target.y - source.pos.y;
                
                // 检查是否同向（背向相邻卫星）
                if ((adjDx * targetDx >= 0 || adjDx === 0) && (adjDy * targetDy >= 0 || adjDy === 0)) {
                    validDirection = true;
                    break;
                }
            }
            if (!validDirection) {
                return false;
            }
            
            // 检查中间是否有且只有一个棋子作为炮架（象棋炮规则）
            const directionX = target.x > source.pos.x ? 1 : (target.x < source.pos.x ? -1 : 0);
            const directionY = target.y > source.pos.y ? 1 : (target.y < source.pos.y ? -1 : 0);
            
            let x = source.pos.x + directionX;
            let y = source.pos.y + directionY;
            let screenCount = 0;
            
            while (x !== target.x || y !== target.y) {
                const piece = getPieceAt({ x, y });
                if (piece) {
                    screenCount++;
                    if (screenCount > 1) {
                        return false; // 中间有多个棋子
                    }
                }
                x += directionX;
                y += directionY;
            }
            
            if (screenCount !== 1) {
                return false; // 中间没有棋子或有多个棋子
            }
            
            // 检查目标是否为敌方棋子
            return targetPiece.color !== source.color;
        }
        
        // 获取相邻同面卫星
        function getAdjacentSameFaceSatellites(satellite) {
            const adjacents = [];
            const directions = [
                { x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: 0, y: 1 }, // 横竖
                { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 } // 斜线
            ];
            
            for (const dir of directions) {
                const pos = { x: satellite.pos.x + dir.x, y: satellite.pos.y + dir.y };
                if (pos.x >= 0 && pos.x < GRID_SIZE && pos.y >= 0 && pos.y < GRID_SIZE) {
                    const piece = getPieceAt(pos);
                    if (piece && piece.type === 'satellite' && piece.color === satellite.color && piece.face === satellite.face) {
                        adjacents.push(piece);
                    }
                }
            }
            
            return adjacents;
        }
        
        // 执行卫星移动
        function applyMove(satellite, target) {
            const targetPiece = getPieceAt(target);
            
            // 检查是否攻击敌方将星
            if (targetPiece && targetPiece.type === 'star' && targetPiece.color !== satellite.color) {
                // 攻击将星，立即获胜
                boardState.winner = satellite.color;
                alert(`${satellite.color === 'red' ? '红方' : '蓝方'}胜利！`);
                // 保存游戏状态
                if (currentGame) {
                    saveGameState();
                }
                return true;
            }
            
            // 检查是否攻击敌方卫星
            if (targetPiece && targetPiece.type === 'satellite' && targetPiece.color !== satellite.color) {
                // 检查是否攻击护卫
                if (isGuard(targetPiece)) {
                    if (!canAttackGuard(satellite, targetPiece)) {
                        return false;
                    }
                }
                // 移除敌方卫星
                if (targetPiece.color === 'red') {
                    boardState.red.satellites = boardState.red.satellites.filter(sat => 
                        sat.pos.x !== targetPiece.pos.x || sat.pos.y !== targetPiece.pos.y
                    );
                } else {
                    boardState.blue.satellites = boardState.blue.satellites.filter(sat => 
                        sat.pos.x !== targetPiece.pos.x || sat.pos.y !== targetPiece.pos.y
                    );
                }
            }
            
            // 更新boardState中的卫星位置
            if (satellite.side === 'red') {
                if (satellite.index !== undefined && satellite.index < boardState.red.satellites.length) {
                    boardState.red.satellites[satellite.index].pos = target;
                }
            } else if (satellite.side === 'blue') {
                if (satellite.index !== undefined && satellite.index < boardState.blue.satellites.length) {
                    boardState.blue.satellites[satellite.index].pos = target;
                }
            }
            return true;
        }
        
        // 执行将星换位
        function applySwap(star, satellite) {
            // 交换位置
            const tempPos = { x: star.pos.x, y: star.pos.y };
            
            // 更新boardState中的将星位置
            if (star.color === 'red') {
                boardState.red.star.x = satellite.pos.x;
                boardState.red.star.y = satellite.pos.y;
            } else if (star.color === 'blue') {
                boardState.blue.star.x = satellite.pos.x;
                boardState.blue.star.y = satellite.pos.y;
            }
            
            // 更新boardState中的卫星位置
            if (satellite.color === 'red') {
                if (satellite.index !== undefined && satellite.index < boardState.red.satellites.length) {
                    boardState.red.satellites[satellite.index].pos.x = tempPos.x;
                    boardState.red.satellites[satellite.index].pos.y = tempPos.y;
                }
            } else if (satellite.color === 'blue') {
                if (satellite.index !== undefined && satellite.index < boardState.blue.satellites.length) {
                    boardState.blue.satellites[satellite.index].pos.x = tempPos.x;
                    boardState.blue.satellites[satellite.index].pos.y = tempPos.y;
                }
            }
            return true;
        }
        
        // 执行炮击（象棋炮规则：飞过炮架，吃掉对方棋子并占据位置）
        function applyCannon(source, target) {
            const targetPiece = getPieceAt(target);
            if (!targetPiece) return false;
            
            // 移除目标
            if (targetPiece.type === 'star') {
                // 攻击将星，立即获胜
                boardState.winner = source.color;
                alert(`${source.color === 'red' ? '红方' : '蓝方'}胜利！`);
                // 保存游戏状态
                if (currentGame) {
                    saveGameState();
                }
                return true;
            } else if (targetPiece.type === 'satellite') {
                // 移除敌方卫星
                if (targetPiece.color === 'red') {
                    boardState.red.satellites = boardState.red.satellites.filter(sat => 
                        sat.pos.x !== targetPiece.pos.x || sat.pos.y !== targetPiece.pos.y
                    );
                } else {
                    boardState.blue.satellites = boardState.blue.satellites.filter(sat => 
                        sat.pos.x !== targetPiece.pos.x || sat.pos.y !== targetPiece.pos.y
                    );
                }
            }
            
            // 移动炮到目标位置（象棋炮规则：炮飞到目标位置）
            if (source.side === 'red') {
                if (source.index !== undefined && source.index < boardState.red.satellites.length) {
                    boardState.red.satellites[source.index].pos = target;
                }
            } else if (source.side === 'blue') {
                if (source.index !== undefined && source.index < boardState.blue.satellites.length) {
                    boardState.blue.satellites[source.index].pos = target;
                }
            }
            
            return true;
        }
        
        // 执行将星对决
        function applyDuel(sourceStar, targetStar) {
            // 移除敌方将星，立即获胜
            boardState.winner = sourceStar.color;
            alert(`${sourceStar.color === 'red' ? '红方' : '蓝方'}胜利！`);
            // 保存游戏状态
            if (currentGame) {
                saveGameState();
                
                // 更新游戏状态为已结束
                try {
                    sb
                        .from('games')
                        .update({ status: 'ended', winner: boardState.winner })
                        .eq('id', currentGame.id);
                    console.log('游戏状态更新为已结束');
                } catch (error) {
                    console.error('更新游戏状态失败:', error);
                }
                
                // 延迟后自动退出游戏
                setTimeout(async function() {
                    // 关闭实时通信通道
                    if (realtimeChannel) {
                        realtimeChannel.unsubscribe();
                        realtimeChannel = null;
                    }
                    
                    // 清理游戏状态
                    currentGame = null;
                    boardState = {
                        turn: 'red',
                        red: {
                            star: { x: 5, y: 10 },
                            satellites: []
                        },
                        blue: {
                            star: { x: 5, y: 0 },
                            satellites: []
                        },
                        winner: null
                    };
                    selectedPiece = null;
                    
                    showLobby();
                }, 2000);
            }
            return true;
        }
        
        // 切换回合
        function switchTurn() {
            boardState.turn = boardState.turn === 'red' ? 'blue' : 'red';
            updateStatusBar();
            
            // 保存游戏状态
            if (currentGame) {
                console.log('切换回合，保存游戏状态');
                saveGameState();
            }
            
            // 检查困毙
            if (checkStalemate()) {
                boardState.winner = boardState.turn === 'red' ? 'blue' : 'red';
                alert(`${boardState.winner === 'red' ? '红方' : '蓝方'}胜利！`);
                // 保存游戏状态
                if (currentGame) {
                    console.log('困毙判定，保存游戏状态');
                    saveGameState();
                }
            }
        }
        
        // 检查困毙
        function checkStalemate() {
            const currentPlayer = boardState.turn;
            const playerState = boardState[currentPlayer];
            
            // 检查卫星是否有合法移动
            for (const satellite of playerState.satellites) {
                // 检查每个方向
                const directions = [
                    { x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: 0, y: 1 }, // 横竖
                    { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 } // 斜线
                ];
                
                for (const dir of directions) {
                    for (let step = 1; step < GRID_SIZE; step++) {
                        const target = {
                            x: satellite.pos.x + dir.x * step,
                            y: satellite.pos.y + dir.y * step
                        };
                        
                        if (target.x < 0 || target.x >= GRID_SIZE || target.y < 0 || target.y >= GRID_SIZE) {
                            break;
                        }
                        
                        if (isValidMove(satellite, target)) {
                            return false;
                        }
                    }
                }
                
                // 检查炮击
                const directionsCannon = [
                    { x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: 0, y: 1 }, // 横竖
                    { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 } // 斜线
                ];
                
                for (const dir of directionsCannon) {
                    for (let step = 2; step < GRID_SIZE; step++) {
                        const target = {
                            x: satellite.pos.x + dir.x * step,
                            y: satellite.pos.y + dir.y * step
                        };
                        
                        if (target.x < 0 || target.x >= GRID_SIZE || target.y < 0 || target.y >= GRID_SIZE) {
                            break;
                        }
                        
                        if (isValidCannon(satellite, target)) {
                            return false;
                        }
                    }
                }
            }
            
            // 检查将星是否可以换位
            const star = playerState.star;
            for (const satellite of playerState.satellites) {
                if (isValidSwap(star, satellite)) {
                    return false;
                }
            }
            
            return true;
        }
        
        // 检查游戏结束
        function checkGameOver() {
            // 检查困毙
            if (checkStalemate()) {
                boardState.winner = boardState.turn === 'red' ? 'blue' : 'red';
                alert(`${boardState.winner === 'red' ? '红方' : '蓝方'}胜利！`);
                return true;
            }
            
            return false;
        }
        
        // 认证逻辑
        let gameStateChannel = null;
        
        async function login(username, password) {
            if (!sb) {
                alert('无法连接到服务器，请稍后再试');
                return false;
            }
            
            const { data, error } = await sb
                .from('users')
                .select('*')
                .eq('username', username)
                .eq('password_hash', password)
                .single();
            
            if (error) {
                alert('登录失败: ' + error.message);
                return false;
            }
            
            // 更新用户在线状态
            const { error: updateError } = await sb
                .from('users')
                .update({ online: true, last_active: new Date().toISOString() })
                .eq('id', data.id);
            
            if (updateError) {
                console.error('更新在线状态失败:', updateError);
            }
            
            currentUser = data;
            currentUser.online = true;
            setupGameStateListener();
            showLobby();
            return true;
        }
        
        async function register(username, password) {
            if (!sb) {
                alert('无法连接到服务器，请稍后再试');
                return false;
            }
            
            const { data, error } = await sb
                .from('users')
                .insert({
                    username,
                    password_hash: password
                })
                .select();
            
            if (error) {
                alert('注册失败: ' + error.message);
                return false;
            }
            
            currentUser = data[0];
            setupGameStateListener();
            showLobby();
            return true;
        }
        
        function setupGameStateListener() {
            if (!sb || !currentUser) return;
            
            // 关闭之前的通道
            if (gameStateChannel) {
                gameStateChannel.unsubscribe();
                gameStateChannel = null;
            }
            
            console.log('设置游戏状态监听器...');
            
            // 创建游戏状态监听通道
            gameStateChannel = sb
                .channel(`game_states:${currentUser.id}`)
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'games'
                }, async payload => {
                    console.log('收到游戏状态更新:', payload);
                    
                    try {
                        const game = payload.new;
                        const userId = currentUser.id;
                        
                        // 检查游戏是否与当前用户相关（创建者或被邀请者）
                        if (game.creator_id === userId || game.invited_id === userId) {
                            // 如果游戏状态变为active，自动进入游戏
                            if (game.status === 'active') {
                                console.log('游戏状态变为active，准备进入游戏...');
                                currentGame = game;
                                
                                // 关闭轮询和通道
                                if (lobbyPollingInterval) {
                                    clearInterval(lobbyPollingInterval);
                                    lobbyPollingInterval = null;
                                }
                                
                                await showGame();
                            }
                        }
                    } catch (error) {
                        console.error('处理游戏状态更新时出错:', error);
                    }
                })
                .on('error', error => {
                    console.error('游戏状态监听器错误:', error);
                    // 尝试重新连接
                    setTimeout(setupGameStateListener, 3000);
                })
                .subscribe((status, error) => {
                    console.log('游戏状态监听器订阅状态:', status);
                    if (error) {
                        console.error('游戏状态监听器订阅错误:', error);
                        // 尝试重新连接
                        setTimeout(setupGameStateListener, 3000);
                    }
                });
        }
        
        async function logout() {
            // 更新用户在线状态为 false
            if (currentUser && sb) {
                try {
                    const { error } = await sb
                        .from('users')
                        .update({ online: false, last_active: new Date().toISOString() })
                        .eq('id', currentUser.id);
                    
                    if (error) {
                        console.error('更新离线状态失败:', error);
                    }
                } catch (error) {
                    console.error('退出时更新状态失败:', error);
                }
            }
            
            currentUser = null;
            currentGame = null;
            
            // 关闭实时通信通道
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
                realtimeChannel = null;
            }
            
            // 关闭游戏状态监听通道
            if (gameStateChannel) {
                gameStateChannel.unsubscribe();
                gameStateChannel = null;
            }
            
            // 停止轮询
            if (lobbyPollingInterval) {
                clearInterval(lobbyPollingInterval);
                lobbyPollingInterval = null;
            }
            
            showAuth();
        }
        
        // 界面切换
        function showAuth() {
            document.getElementById('authScreen').style.display = 'block';
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
        }
        
        let lobbyPollingInterval = null;
        
        function showLobby() {
            document.getElementById('authScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
            loadLobbyData();
            
            // 启动轮询，每3秒刷新一次大厅数据
            if (lobbyPollingInterval) {
                clearInterval(lobbyPollingInterval);
            }
            lobbyPollingInterval = setInterval(loadLobbyData, 3000);
            
            console.log('进入游戏大厅，游戏状态监听器已在登录时设置');
        }
        
        async function showGame() {
            document.getElementById('authScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            initBoard();
            
            // 停止轮询
            if (lobbyPollingInterval) {
                clearInterval(lobbyPollingInterval);
                lobbyPollingInterval = null;
            }
            
            // 更新游戏信息显示
            if (currentGame) {
                // 获取红方和蓝方玩家信息
                let redPlayerName = '未知';
                let bluePlayerName = '未知';
                
                try {
                    // 获取红方玩家信息
                    if (currentGame.red_player_id) {
                        const { data: redPlayer, error: redError } = await sb
                            .from('users')
                            .select('username')
                            .eq('id', currentGame.red_player_id)
                            .single();
                        if (!redError && redPlayer) {
                            redPlayerName = redPlayer.username;
                        }
                    }
                    
                    // 获取蓝方玩家信息
                    if (currentGame.blue_player_id) {
                        const { data: bluePlayer, error: blueError } = await sb
                            .from('users')
                            .select('username')
                            .eq('id', currentGame.blue_player_id)
                            .single();
                        if (!blueError && bluePlayer) {
                            bluePlayerName = bluePlayer.username;
                        }
                    }
                } catch (error) {
                    console.error('获取玩家信息失败:', error);
                }
                
                // 显示红方和蓝方玩家信息
                document.getElementById('redPlayer').textContent = redPlayerName;
                document.getElementById('bluePlayer').textContent = bluePlayerName;
                document.getElementById('gameStatus').textContent = '游戏中';
                
                // 初始化游戏状态
                console.log('初始化游戏状态');
                saveGameState();
                
                // 初始化实时通信通道
                console.log('初始化实时通信通道');
                setupRealtime(currentGame.id);
            }
        }
        
        // 游戏大厅逻辑
        async function loadLobbyData() {
            if (!sb) {
                alert('无法连接到服务器，请稍后再试');
                return;
            }
            
            // 加载在线玩家
            const { data: players, error: playersError } = await sb
                .from('users')
                .select('*')
                .eq('online', true);
            
            if (!playersError) {
                const playerList = document.getElementById('playerList');
                playerList.innerHTML = '';
                players.forEach(player => {
                    if (player.id !== currentUser.id) {
                        const playerItem = document.createElement('div');
                        playerItem.className = 'player-item';
                        playerItem.innerHTML = `
                            <span>${player.username}</span>
                            <button class="invite-button" onclick="invitePlayer('${player.id}')">邀请</button>
                        `;
                        playerList.appendChild(playerItem);
                    }
                });
            }
            
            // 加载游戏邀请
            const { data: games, error: gamesError } = await sb
                .from('games')
                .select('*')
                .eq('invited_id', currentUser.id)
                .eq('status', 'pending');
            
            if (!gamesError) {
                const gameInvites = document.getElementById('gameInvites');
                gameInvites.innerHTML = '';
                games.forEach(game => {
                    const gameItem = document.createElement('div');
                    gameItem.className = 'game-item';
                    gameItem.innerHTML = `
                        <div>收到游戏邀请</div>
                        <button class="accept-button" onclick="acceptInvite('${game.id}')">接受</button>
                        <button class="reject-button" onclick="rejectInvite('${game.id}')">拒绝</button>
                    `;
                    gameInvites.appendChild(gameItem);
                });
            }
            
            // 检查作为创建者的游戏状态（备份机制）
            const { data: createdGames, error: createdGamesError } = await sb
                .from('games')
                .select('*')
                .eq('creator_id', currentUser.id);
            
            if (!createdGamesError && createdGames.length > 0) {
                for (const game of createdGames) {
                    if (game.status === 'active') {
                        console.log('轮询检测到游戏状态变为active，准备进入游戏...');
                        currentGame = game;
                        
                        // 关闭轮询
                        if (lobbyPollingInterval) {
                            clearInterval(lobbyPollingInterval);
                            lobbyPollingInterval = null;
                        }
                        
                        await showGame();
                        return;
                    }
                }
            }
        }
        
        async function invitePlayer(playerId) {
            if (!sb) {
                alert('无法连接到服务器，请稍后再试');
                return;
            }
            
            const { data, error } = await sb
                .from('games')
                .insert({
                    creator_id: currentUser.id,
                    invited_id: playerId,
                    status: 'pending'
                })
                .select();
            
            if (error) {
                alert('邀请失败: ' + error.message);
            } else {
                alert('邀请已发送');
                // 刷新大厅数据
                loadLobbyData();
            }
        }
        
        async function acceptInvite(gameId) {
            if (!sb) {
                alert('无法连接到服务器，请稍后再试');
                return;
            }
            
            const { data: game, error: gameError } = await sb
                .from('games')
                .select('*')
                .eq('id', gameId)
                .single();
            
            if (gameError) {
                alert('获取游戏信息失败');
                return;
            }
            
            const { error: updateError } = await sb
                .from('games')
                .update({
                    status: 'active',
                    red_player_id: game.creator_id,
                    blue_player_id: currentUser.id
                })
                .eq('id', gameId);
            
            if (updateError) {
                alert('接受邀请失败: ' + updateError.message);
                return;
            }
            
            // 重新获取更新后的游戏信息
            const { data: updatedGame, error: updatedGameError } = await sb
                .from('games')
                .select('*')
                .eq('id', gameId)
                .single();
            
            if (updatedGameError) {
                console.error('获取更新后的游戏信息失败:', updatedGameError);
                // 即使获取失败，也使用原始游戏信息继续
                currentGame = game;
            } else {
                currentGame = updatedGame;
            }
            
            await showGame();
        }
        
        async function rejectInvite(gameId) {
            if (!sb) {
                alert('无法连接到服务器，请稍后再试');
                return;
            }
            
            const { error } = await sb
                .from('games')
                .update({ status: 'rejected' })
                .eq('id', gameId);
            
            if (error) {
                alert('拒绝邀请失败: ' + error.message);
            } else {
                loadLobbyData();
            }
        }
        
        // 实时游戏同步
        function setupRealtime(gameId) {
            if (!sb) return;
            
            realtimeChannel = sb
                .channel(`game:${gameId}`)
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'game_states',
                    filter: `game_id=eq.${gameId}`
                }, payload => {
                    try {
                        // 更新游戏状态
                        const gameState = payload.new.board_state;
                        // 检查类型，Supabase 可能已经解析为对象
                        if (typeof gameState === 'string') {
                            boardState = JSON.parse(gameState);
                        } else {
                            boardState = gameState;
                        }
                        drawBoard();
                        console.log('游戏状态实时更新成功:', boardState);
                    } catch (error) {
                        console.error('处理游戏状态更新时出错:', error);
                        console.error('原始数据:', payload.new.board_state);
                    }
                })
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'game_states',
                    filter: `game_id=eq.${gameId}`
                }, payload => {
                    try {
                        // 初始游戏状态
                        const gameState = payload.new.board_state;
                        // 检查类型，Supabase 可能已经解析为对象
                        if (typeof gameState === 'string') {
                            boardState = JSON.parse(gameState);
                        } else {
                            boardState = gameState;
                        }
                        drawBoard();
                        console.log('初始游戏状态同步成功:', boardState);
                    } catch (error) {
                        console.error('处理初始游戏状态时出错:', error);
                        console.error('原始数据:', payload.new.board_state);
                    }
                })
                .on('error', error => {
                    console.error('实时通信错误:', error);
                    // 尝试重新连接
                    setTimeout(() => setupRealtime(gameId), 3000);
                })
                .subscribe((status, error) => {
                    console.log('实时通信订阅状态:', status);
                    if (error) {
                        console.error('实时通信订阅错误:', error);
                    }
                });
        }
        
        async function saveGameState() {
            if (!currentGame || !sb) return;
            
            console.log('开始保存游戏状态，游戏ID:', currentGame.id);
            console.log('当前棋盘状态:', boardState);
            
            try {
                const { data, error } = await sb
                    .from('game_states')
                    .upsert({
                        game_id: currentGame.id,
                        board_state: JSON.stringify(boardState),
                        current_turn: boardState.turn,
                        move_count: (currentGame.move_count || 0) + 1
                    })
                    .select();
                
                if (error) {
                    console.error('保存游戏状态失败: ', error);
                } else {
                    console.log('游戏状态保存成功，返回数据:', data);
                }
            } catch (error) {
                console.error('保存游戏状态时出错:', error);
            }
        }
        
        // 初始化事件监听器
        function initEventListeners() {
            // 认证事件
            document.getElementById('loginBtn').addEventListener('click', function() {
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                login(username, password);
            });
            
            document.getElementById('registerBtn').addEventListener('click', function() {
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                register(username, password);
            });
            
            document.getElementById('logoutBtn').addEventListener('click', async function() {
                await logout();
            });
            document.getElementById('exitGameBtn').addEventListener('click', async function() {
                // 关闭实时通信通道
                if (realtimeChannel) {
                    realtimeChannel.unsubscribe();
                    realtimeChannel = null;
                }
                
                // 更新游戏状态为已退出
                if (currentGame) {
                    try {
                        await sb
                            .from('games')
                            .update({ status: 'ended' })
                            .eq('id', currentGame.id);
                        console.log('游戏状态更新为已退出');
                    } catch (error) {
                        console.error('更新游戏状态失败:', error);
                    }
                }
                
                // 清理游戏状态
                currentGame = null;
                boardState = {
                    turn: 'red',
                    red: {
                        star: { x: 5, y: 10 },
                        satellites: []
                    },
                    blue: {
                        star: { x: 5, y: 0 },
                        satellites: []
                    },
                    winner: null
                };
                selectedPiece = null;
                
                showLobby();
            });
            
            // 游戏事件
            const canvas = document.getElementById('gameCanvas');
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            
            // 投降按钮
            document.getElementById('surrenderBtn').addEventListener('click', async function() {
                if (boardState.winner) return;
                
                // 确定投降方和胜利方
                const surrenderColor = boardState.turn;
                const winnerColor = surrenderColor === 'red' ? 'blue' : 'red';
                boardState.winner = winnerColor;
                
                // 显示胜利信息
                alert(`${winnerColor === 'red' ? '红方' : '蓝方'}胜利！`);
                
                // 保存游戏状态
                if (currentGame) {
                    await saveGameState();
                    
                    // 更新游戏状态为已结束
                    try {
                        await sb
                            .from('games')
                            .update({ status: 'ended', winner: winnerColor })
                            .eq('id', currentGame.id);
                        console.log('游戏状态更新为已结束');
                    } catch (error) {
                        console.error('更新游戏状态失败:', error);
                    }
                }
                
                drawBoard();
                
                // 延迟后自动退出游戏
                setTimeout(async function() {
                    // 关闭实时通信通道
                    if (realtimeChannel) {
                        realtimeChannel.unsubscribe();
                        realtimeChannel = null;
                    }
                    
                    // 清理游戏状态
                    currentGame = null;
                    boardState = {
                        turn: 'red',
                        red: {
                            star: { x: 5, y: 10 },
                            satellites: []
                        },
                        blue: {
                            star: { x: 5, y: 0 },
                            satellites: []
                        },
                        winner: null
                    };
                    selectedPiece = null;
                    
                    showLobby();
                }, 2000);
            });
            
            // 悔棋按钮
            document.getElementById('regretBtn').addEventListener('click', function() {
                alert('落子无悔');
            });
        }
        
        // 修改switchTurn函数，在每次移动后保存游戏状态
        function switchTurn() {
            boardState.turn = boardState.turn === 'red' ? 'blue' : 'red';
            updateStatusBar();
            
            // 保存游戏状态
            if (currentGame) {
                saveGameState();
            }
            
            // 检查困毙
            if (checkStalemate()) {
                boardState.winner = boardState.turn === 'red' ? 'blue' : 'red';
                alert(`${boardState.winner === 'red' ? '红方' : '蓝方'}胜利！`);
                if (currentGame) {
                    saveGameState();
                    
                    // 更新游戏状态为已结束
                    try {
                        sb
                            .from('games')
                            .update({ status: 'ended', winner: boardState.winner })
                            .eq('id', currentGame.id);
                        console.log('游戏状态更新为已结束');
                    } catch (error) {
                        console.error('更新游戏状态失败:', error);
                    }
                    
                    // 延迟后自动退出游戏
                    setTimeout(async function() {
                        // 关闭实时通信通道
                        if (realtimeChannel) {
                            realtimeChannel.unsubscribe();
                            realtimeChannel = null;
                        }
                        
                        // 清理游戏状态
                        currentGame = null;
                        boardState = {
                            turn: 'red',
                            red: {
                                star: { x: 5, y: 10 },
                                satellites: []
                            },
                            blue: {
                                star: { x: 5, y: 0 },
                                satellites: []
                            },
                            winner: null
                        };
                        selectedPiece = null;
                        
                        showLobby();
                    }, 2000);
                }
            }
        }
        
        // 页面加载完成后初始化
        window.onload = function() {
            initEventListeners();
        };
    </script>
</body>
</html>